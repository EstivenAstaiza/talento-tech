# -*- coding: utf-8 -*-
"""Trabajo final talento tech.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z_ZpCJCVAEVPhMYhUiPSBSYaT_zBez9p

# **1. Analisis Diabetes**
**Descripción general del dataset:**
Este dataset contiene información sobre pacientes y características relacionadas con la diabetes.

**Características del dataset:** <br>
Número total de características: 10
Características numéricas:Todas las características son numéricas <br>
Características categóricas: No hay características categóricas explícitas<br>
Variable objetivo: Se binariza la variable target original (continua) para crear una variable categórica

**Características numéricas:**<br>
age: Edad <br>
sex: Sexo <br>
bmi: Índice de masa corporal <br>
bp: Presión arterial media <br>
s1: Nivel de colesterol total en suero <br>
s2: Lipoproteínas de baja densidad (LDL)<br>
s3: Lipoproteínas de alta densidad (HDL)<br>
s4: Nivel de colesterol en suero<br>
s5: Nivel de triglicéridos en suero<br>
s6: Nivel de azúcar en sangre<br>

# **2. Objetivo del proyecto:**
El objetivo principal parece ser predecir el riesgo de diabetes en pacientes basándose en sus características médicas. Esto se realiza mediante una combinación de técnicas de clustering y clasificación.

**Resumen del análisis:**<br>
**a) Preprocesamiento de datos:**

Se carga el dataset de diabetes y se crea un DataFrame.
Se binariza la variable objetivo (target) para aplicar regresión logística.

**b) Análisis exploratorio:**

Se visualiza la matriz de correlaciones entre las características.<br>

**c) Clustering:**

Se seleccionan tres características para el clustering: 'bmi', 'bp', y 's1'.
Se aplica el algoritmo K-means con 3 clusters.
Se visualizan los clusters utilizando PCA para reducir la dimensionalidad.

**d) Modelado predictivo:**

Se utiliza regresión logística para predecir el riesgo de diabetes.
Se divide el dataset en conjuntos de entrenamiento y prueba.
Se evalúa el modelo utilizando métricas como precisión, exactitud y recall.

**e) Aplicación práctica:**

Se implementa una función para que el usuario ingrese sus datos y obtener una predicción sobre su riesgo de diabetes.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.datasets import load_diabetes
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn import metrics
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA

# Cargar dataset de diabetes
datos = load_diabetes()
print(datos.DESCR)

# Crear DataFrame
df = pd.DataFrame(datos.data, columns=datos.feature_names)
df['Target'] = (datos.target > np.median(datos.target)).astype(int)  # Binarizamos el target para aplicar regresión logística

# Visualizar primeras filas del dataset
print(df.head(5))

# Visualizar correlaciones
columnas = df.columns.values
MC = np.corrcoef(df[columnas].values.T)

# Graficar mapa de calor de la matriz de correlaciones
sns.heatmap(MC, yticklabels=columnas, xticklabels=columnas, cbar=True, annot=True)
plt.title('Matriz de correlaciones entre características')
plt.show()

# Selección de variables
columnas_seleccionadas = ['bmi', 'bp', 's1', 'Target']
df_filtrado = df[columnas_seleccionadas]
X_clustering = df[columnas_seleccionadas]

# División de los datos en características (X) y la variable objetivo (y)
X = df_filtrado.drop(['Target'], axis=1)
y = df_filtrado['Target']

# Estandarización de las características
scaler = StandardScaler()
X_scaled_clustering = scaler.fit_transform(X_clustering)
###############

# Estandarización de las características
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Aplicar algoritmo de clustering K-means
kmeans = KMeans(n_clusters=3, random_state=42)
clusters = kmeans.fit_predict(X_scaled_clustering)

# Añadir los clusters al DataFrame
df['Cluster'] = clusters

# Visualización de clusters con PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled_clustering)

plt.scatter(X_pca[:, 0], X_pca[:, 1], c=clusters, cmap='viridis', s=50)
plt.title('Clusters de Pacientes (K-means)')
plt.xlabel('Componente Principal 1')
plt.ylabel('Componente Principal 2')
plt.colorbar(label='Cluster')
plt.show()

# Clustering y regresión logística
X = df_filtrado.drop(['Target'], axis=1)
y = df_filtrado['Target']

# División del dataset en conjunto de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Modelo de Regresión Logística
modelo = LogisticRegression()
modelo.fit(X_train, y_train)

# Predicción
y_pred_train = modelo.predict(X_train)
y_pred_test = modelo.predict(X_test)

# Evaluación del modelo
matriz_confusion = metrics.confusion_matrix(y_test, y_pred_test)
print(f'Matriz de Confusión:\n{matriz_confusion}')

# Métricas de evaluación
precision = metrics.precision_score(y_test, y_pred_test)
exactitud = metrics.accuracy_score(y_test, y_pred_test)
recall = metrics.recall_score(y_test, y_pred_test)

print(f'Precisión: {precision}')
print(f'Exactitud: {exactitud}')
print(f'Recall: {recall}')

# Visualización de la matriz de confusión
sns.heatmap(matriz_confusion, annot=True, fmt='d', cmap='Blues')
plt.title('Matriz de Confusión')
plt.xlabel('Predicción')
plt.ylabel('Real')
plt.show()

# Predicción con entrada del usuario
nombre = input("Ingrese su nombre: ")
print("Ingrese los valores de 'bmi', 'bp', 's1'")
bmi = float(input("Ingrese el valor para bmi: "))
bp = float(input("Ingrese el valor para bp: "))
s1 = float(input("Ingrese el valor para s1: "))

# Crear DataFrame con los datos ingresados por el usuario
dato_entrada = pd.DataFrame([[bmi, bp, s1]], columns=['bmi', 'bp', 's1'])

# Estandarizar los datos de entrada
dato_entrada_scaled = scaler.transform(dato_entrada)

# Realizar la predicción
prediccion = modelo.predict(dato_entrada_scaled)

# Mostrar el resultado al usuario
if prediccion == 1:
    print(f"{nombre}, según los valores ingresados, el sistema predice que tiene riesgo de diabetes.")
else:
    print(f"{nombre}, según los valores ingresados, el sistema predice que no tiene riesgo de diabetes.")

"""# **Conclusión general:**<br>
El análisis combina técnicas de aprendizaje no supervisado (clustering) y supervisado (clasificación) para abordar el problema de predecir el riesgo de diabetes. El clustering ayuda a identificar grupos de pacientes con características similares, mientras que la regresión logística se utiliza para la clasificación binaria del riesgo de diabetes.
"""
